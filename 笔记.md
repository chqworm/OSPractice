# 操作系统笔记

[课程链接](https://github.com/cfenollosa/os-tutorial)

## 传统Bios启动顺序

1. cpu上电重置  
   CPU 加电复位进入实模式，PC（程序计数器）指向 固定地址（x86 通常是CS:IP 0xFFFF:0x0000或EIP/RIP 初始值是 0xFFFFFFF0）。从这个地址开始 执行 BIOS 固件中的第一条指令。
  
   | CPU 类型 |初始模式|初始PC说明|  
   |:-------  |:---   |:--------|
   |8086/8088 |实模式 (16 位)|CS:IP = FFFF:0000 → 物理 0xFFFF0 老 CPU，只能实模式|
   | 386/486  |实模式 (16 位)| CS:IP = FFFF:0000 → 物理 0xFFFF0 支持保护模式，但上电仍先实模式|
   | x86-64   |实模式 (16 位) | 逻辑地址 0xFFFFFFF0 → 映射到 BIOS ROM 后续可切换到 32 位保护模式，再切换到 64 位 Long Mode|

   逻辑地址和物理地址可以不一致：逻辑地址：0xFFFFFFF0（CPU看到的地址），物理地址：ROM 芯片的实际位置，通常是 系统地址空间顶端，CPU 通过 总线逻辑/映射表把逻辑地址映射到BIOS ROM。

2. BIOS 初始化
   
   执行 POST（Power-On Self Test）：检测内存、键盘、显卡等；
   
   初始化硬件控制器；
   
   可以显示初步信息（厂商 Logo / 键盘提示）；

## UEFI和BIOS的对比

   |特性    |BIOS              | UEFI|
   |:-------|:---|:------|             
   |启动方式 |MBR + 单扇区引导 |   EFI 分区 + 可执行文件 .efi|
   |地址限制 |16/32 位寻址      |  32/64 位寻址，无 2TB 限制|
   |文件系统 |无（直接读扇区）  |   支持 FAT32/EFI 文件系统，直接读取文件|
   |界面     | 文本             |  可以有图形界面、鼠标支持|
   |扩展性   | 很有限           |  支持驱动加载、网络启动、安全启动、Shell|
   |安全性   | 无               |  支持 Secure Boot 防止非法启动|

   UEFI全称：Unified Extensible Firmware Interface（统一可扩展固件接口）  
位置：依旧存储在 Flash / ROM 芯片里，但核心的 引导程序部分（EFI 可执行文件）在 EFI 系统分区（ESP） 的硬盘上；  
性质：固件 + 可执行程序环境（像一个小型操作系统）可以运行.efi 文件、加载驱动、提供 Shell作用、初始化硬件（类似 BIOS）、提供启动管理器（Boot Manager），可以通过 UEFI API 访问硬件，而不用传统 BIOS 中断；  
特点：支持图形界面、鼠标、网络、文件系统，支持大容量硬盘（>2TB）、安全启动（Secure Boot），扩展性强，可加载驱动或其他应用程序；  


## nasm命令参数

   nasm -f  format -o filename -l filename.lst -g  
   format 输出目标文件格式elf64、win64、macho64、bin，需要链接生成可执行文件。  
   elf64:  linux64下.o目标文件格式;  
   win64: windows64下obj目标文件格式;  
   macho64: 苹果系统下.o目标文件格式;  
   Bin:裸机格式，启动扇区，qemu可直接启动;  
   要开发linux和windows程序，先用nams编译成目标文件文件，然后Linux通过ld或gcc，Windows通过link（MSVC）或ld（MinGW）

## 汇编语言
1. 裸镜像
   
裸镜像：原始字节序列文件，直接表示磁盘或存储设备的内容
不包含任何 QEMU、虚拟化软件特有的头信息或元数据
例如： 
一个 512 字节的启动扇区 bootsect.bin
一个 1MB 的虚拟磁盘 disk.img，里面可能有文件系统，但文件本身就是纯二进制

裸镜像的内容就是启动盘里的内容，只是载体不一样。
QEMU报警告是因为启动数据不是qcow2（QEMU 专用格式，有元数据、快照支持）或vhd/vmdk（虚拟机软件专用格式，有磁盘头信息、快照支持）
显式告诉 QEMU 这是 raw 格式：
qemu-system-x86_64.exe -drive format=raw,file=bootsimple.bin
或者：
qemu-system-x86_64.exe -fda bootsimple.bin
对于 单扇区启动程序，推荐用 -fda（把它当软盘）
对于完整虚拟磁盘，可以用 -drive format=raw,file=...

2. 单扇区启动程序的定义
   
单扇区启动程序 = 最小可启动程序，只占用 一个扇区（512 字节）。
特点：最后两个字节是 0x55AA 启动标志,放在磁盘第 0 扇区,BIOS 或 QEMU 可以直接加载执行。
可以理解为“计算机启动最小单位的程序”，用于教学、OS 实验或者引导代码测试。

3. 多扇区启动程序
   
定义：启动程序占用 多个扇区，不止 512 字节
原理：BIOS 只会读取第一个扇区（第 0 扇区）,第 0 扇区程序再负责加载剩余扇区到内存。  
典型用途：加载操作系统核心（kernel）。
启动复杂程序或 OS，举例：GRUB、Linux 的 bootloader 都是多扇区启动程序。
多扇区一定会先有一个单扇区引导，只不过多扇区的第一个扇区的目的是装载后面的扇区。

## 第九节读取磁盘

引导扇区代码从硬盘载入内核代码。因为我们的os代码不只512字节，我们需要从硬盘读取内核代码来运行内核。我们不必直接控制处理磁盘，我们只需要调用bios的例程（一段代码），就像我们在屏幕上打印字符。

1. 硬盘结构 **-----不写了，** 
   
需要了解硬盘，盘片，片面，柱面，磁头，扇区，进位。 
盘片、片面和磁头:硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。
 如下图：
 
 ![abc](https://ask.qcloudimg.com/http-save/yehe-2141641/hl841xd6on.png)

2. 硬盘服务中断 `int 13h`
硬盘中断指令`int 13h`常用功能为读写扇区：

- AH = 02h：读扇区
- AH = 03h：写扇区
- AH = 04h：校验扇区
- AH = 05h：格式化磁道（软盘）
  
要读取硬盘数据，需将ah设置为0x02，并且其他寄存器设置所要读取的柱面，磁头和扇区号，然后调用 int 0x13。

```asm
mov  ah, 02h         ; 调用读扇区功能
mov  al, numSecs     ; 要读取的扇区总数目
mov  ch, track       ；要读取的磁道号，柱面cynder，和cl的高两位结合使用可访问1024个磁道。
mov  cl, sector      ；要读取的起始扇区号，从1开始，只使用低6六位，扇区最大为64，能满足老硬盘，现代硬盘不行了
mov  dh, head        ；要读取的磁头
mov  dl, drive       ；要读取的硬盘驱动器，00h:第一个软盘,01h:第二个软盘,80h:第一个硬盘,81h:第二个硬盘，依此类推
int  13h
```
调用 BIOS 磁盘服务中断，执行读扇区操作。

返回后，寄存器状态：

CF = 0 → 没有错误

CF = 1 → 发生错误，错误码在 AH

AL → 实际读到的扇区数（可能小于请求数量）
这里我们将使用进位(the carry bit), 每一个寄存器有一个额外bit。但某个运算使得计算器溢出，该比特位用了存储该溢出标志:

```asm
mov ax, 0xFFFF
add ax, 1 ; ax = 0x0000 and carry = 1
```

这个进位不能直接访问，但可以通过其他操作指令来控制结构，比如跳转指令`jc`（如果进位被设置则跳转）


The BIOS also sets al to the number of sectors read, so always compare it to the expected number.

