# 操作系统笔记

[课程链接](https://github.com/cfenollosa/os-tutorial)

## 传统Bios启动顺序

1. cpu上电重置  
   CPU 加电复位进入实模式，PC（程序计数器）指向 固定地址（x86 通常是CS:IP 0xFFFF:0x0000或EIP/RIP 初始值是 0xFFFFFFF0）。从这个地址开始 执行 BIOS 固件中的第一条指令。
  
   | CPU 类型 |初始模式|初始PC说明|  
   |:-------  |:---   |:--------|
   |8086/8088 |实模式 (16 位)|CS:IP = FFFF:0000 → 物理 0xFFFF0 老 CPU，只能实模式|
   | 386/486  |实模式 (16 位)| CS:IP = FFFF:0000 → 物理 0xFFFF0 支持保护模式，但上电仍先实模式|
   | x86-64   |实模式 (16 位) | 逻辑地址 0xFFFFFFF0 → 映射到 BIOS ROM 后续可切换到 32 位保护模式，再切换到 64 位 Long Mode|

   逻辑地址和物理地址可以不一致：逻辑地址：0xFFFFFFF0（CPU看到的地址），物理地址：ROM 芯片的实际位置，通常是 系统地址空间顶端，CPU 通过 总线逻辑/映射表把逻辑地址映射到BIOS ROM。

2. BIOS 初始化
   
   执行 POST（Power-On Self Test）：检测内存、键盘、显卡等；
   
   初始化硬件控制器；
   
   可以显示初步信息（厂商 Logo / 键盘提示）；

## UEFI和BIOS的对比

   |特性    |BIOS              | UEFI|
   |:-------|:---|:------|             
   |启动方式 |MBR + 单扇区引导 |   EFI 分区 + 可执行文件 .efi|
   |地址限制 |16/32 位寻址      |  32/64 位寻址，无 2TB 限制|
   |文件系统 |无（直接读扇区）  |   支持 FAT32/EFI 文件系统，直接读取文件|
   |界面     | 文本             |  可以有图形界面、鼠标支持|
   |扩展性   | 很有限           |  支持驱动加载、网络启动、安全启动、Shell|
   |安全性   | 无               |  支持 Secure Boot 防止非法启动|

   UEFI全称：Unified Extensible Firmware Interface（统一可扩展固件接口）  
位置：依旧存储在 Flash / ROM 芯片里，但核心的 引导程序部分（EFI 可执行文件）在 EFI 系统分区（ESP） 的硬盘上；  
性质：固件 + 可执行程序环境（像一个小型操作系统）可以运行.efi 文件、加载驱动、提供 Shell作用、初始化硬件（类似 BIOS）、提供启动管理器（Boot Manager），可以通过 UEFI API 访问硬件，而不用传统 BIOS 中断；  
特点：支持图形界面、鼠标、网络、文件系统，支持大容量硬盘（>2TB）、安全启动（Secure Boot），扩展性强，可加载驱动或其他应用程序；  


## nasm命令参数

nasm -f  format -o filename -l filename.lst -g  
   要开发linux和windows程序，先用nams编译成目标文件文件，然后Linux通过ld或gcc，Windows通过link（MSVC）或ld（MinGW）

* -f <format> → 指定输出格式（object format），例如：
   * bin → 生成原始二进制文件（裸机 / 引导扇区），qemu可直接启动;  
   * elf32 → 生成 32 位 Linux ELF 文件
   * win32 → 生成 Windows 32 位对象文件
   * win64 → 生成 Windows 64 位对象文件
   * macho64: 苹果系统下.o目标文件格式;  
* -o <filename> → 指定输出文件名称，生成的二进制或目标文件
* -l <filename.lst> → 生成 汇编列表文件，包含源代码和对应的机器码（便于调试或查看）
* -g → 生成调试信息，方便调试器（如 GDB）使用

## 汇编语言
1. 裸镜像
   
裸镜像：原始字节序列文件，直接表示磁盘或存储设备的内容
不包含任何 QEMU、虚拟化软件特有的头信息或元数据
例如： 
一个 512 字节的启动扇区 bootsect.bin
一个 1MB 的虚拟磁盘 disk.img，里面可能有文件系统，但文件本身就是纯二进制

裸镜像的内容就是启动盘里的内容，只是载体不一样。
QEMU报警告是因为启动数据不是qcow2（QEMU 专用格式，有元数据、快照支持）或vhd/vmdk（虚拟机软件专用格式，有磁盘头信息、快照支持）
显式告诉 QEMU 这是 raw 格式：
qemu-system-x86_64.exe -drive format=raw,file=bootsimple.bin
或者：
qemu-system-x86_64.exe -fda bootsimple.bin
对于 单扇区启动程序，推荐用 -fda（把它当软盘）
对于完整虚拟磁盘，可以用 -drive format=raw,file=...

2. 单扇区启动程序的定义
   
单扇区启动程序 = 最小可启动程序，只占用 一个扇区（512 字节）。
特点：最后两个字节是 0x55AA 启动标志,放在磁盘第 0 扇区,BIOS 或 QEMU 可以直接加载执行。
可以理解为“计算机启动最小单位的程序”，用于教学、OS 实验或者引导代码测试。

3. 多扇区启动程序
   
定义：启动程序占用 多个扇区，不止 512 字节
原理：BIOS 只会读取第一个扇区（第 0 扇区）,第 0 扇区程序再负责加载剩余扇区到内存。  
典型用途：加载操作系统核心（kernel）。
启动复杂程序或 OS，举例：GRUB、Linux 的 bootloader 都是多扇区启动程序。
多扇区一定会先有一个单扇区引导，只不过多扇区的第一个扇区的目的是装载后面的扇区。

## 第九节读取磁盘

引导扇区代码从硬盘载入内核代码。因为我们的os代码不只512字节，我们需要从硬盘读取内核代码来运行内核。我们不必直接控制处理磁盘，我们只需要调用bios的例程（一段代码），就像我们在屏幕上打印字符。

1. 硬盘结构 **-----不写了，** 
   
需要了解硬盘，盘片，片面，柱面，磁头，扇区，进位。 
盘片、片面和磁头:硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。
 如下图：
 
 ![abc](https://ask.qcloudimg.com/http-save/yehe-2141641/hl841xd6on.png)

2. 硬盘服务中断 `int 13h`
硬盘中断指令`int 13h`常用功能为读写扇区：

- AH = 02h：读扇区
- AH = 03h：写扇区
- AH = 04h：校验扇区
- AH = 05h：格式化磁道（软盘）
  
要读取硬盘数据，需将ah设置为0x02，并且其他寄存器设置所要读取的柱面，磁头和扇区号，然后调用 int 0x13。

```asm
mov  ah, 02h         ; 调用读扇区功能
mov  al, numSecs     ; 要读取的扇区总数目
mov  ch, track       ；要读取的磁道号，柱面cynder，和cl的高两位结合使用可访问1024个磁道。
mov  cl, sector      ；要读取的起始扇区号，从1开始，只使用低6六位，扇区最大为64，能满足老硬盘，现代硬盘不行了
mov  dh, head        ；要读取的磁头
mov  dl, drive       ；要读取的硬盘驱动器，00h:第一个软盘,01h:第二个软盘,80h:第一个硬盘,81h:第二个硬盘，依此类推
int  13h             ; 调用 BIOS 磁盘服务中断
```

调用 BIOS 磁盘服务中断，执行读扇区操作。

返回后，寄存器状态：

CF = 0 → 没有错误

CF = 1 → 发生错误，错误码在 AH

AL → 实际读到的扇区数（可能小于请求数量）
这里我们将使用进位(the carry bit), 每一个寄存器有一个额外bit。但某个运算使得计算器溢出，该比特位用了存储该溢出标志:

```asm
mov ax, 0xFFFF
add ax, 1 ; ax = 0x0000 and carry = 1
```

这个进位不能直接访问，但可以通过其他操作指令来控制结构，比如跳转指令`jc`（如果进位被设置则跳转）

在这个，这个进位不表示是否有进位，而是表示是否读取成功，如果读取成功，则进位为0，失败为1，

当 BIOS 读盘操作完成后，AL寄存器里会存放“实际成功读取的扇区数量”。

读取硬盘主程序代码 boot_sect_main.asm：
```asm
   [org 0x7c00]     ; nasm 伪指令，后面的内存地址都以0x0000：7c00处为起始0地址；
   mov bp, 0x8000   ; bp是栈基址指针寄存器，不随 push/pop 自动改变set the stack safely away from us
   mov sp, bp       ; 栈指针寄存器,指向栈顶,操作 push/pop 时自动改变,栈向下增长,物理栈地址 = SS*16 + SP

   mov bx, 0x9000   ; 基址寄存器，可指向数据段内任意地址,es:bx = 0x0000:0x9000 = 0x09000 ES = 段寄存器，BX = 偏移 
                    ; disk_load 将数据存入该地址 
   mov dh, 2 ; read 2 sectors
   ; the bios sets 'dl' for our boot disk number
   ; if you have trouble, use the '-fda' flag: 'qemu -fda file.bin'
   call disk_load
   mov dx, [0x9000] ; retrieve the first loaded word, 0xdada
   call print_hex
   call print_nl
   mov dx, [0x9000 + 512] ; first word from second loaded sector, 0xface
   call print_hex
   jmp $

   %include "../05-bootsector-functions-strings/boot_sect_print.asm"
   %include "../05-bootsector-functions-strings/boot_sect_print_hex.asm"
   %include "boot_sect_disk.asm"

   ; Magic number
   times 510 - ($-$$) db 0
   dw 0xaa55

   ; boot sector = sector 1 of cyl 0 of head 0 of hdd 0
   ; from now on = sector 2 ...
   times 256 dw 0xdada ; sector 2 = 512 bytes
   times 256 dw 0xface ; sector 3 = 512 bytes
```

读取硬盘子例程代码 boot_sect_disk.asm：
```asm
   ; load 'dh' sectors from drive 'dl' into ES:BX
disk_load:
   pusha ; 把AX,CX,DX,BX,SP,BP,SI,DI八个16位寄存器的当前值依次压入栈中,在压入栈时，会先减SP（栈向下生长），再存值
   ; reading from disk requires setting specific values in all registers
   ; so we will overwrite our input parameters from 'dx'. Let's save it
   ; to the stack for later use.
   push dx

   mov ah, 0x02 ; ah <- int 0x13 function. 0x02 = 'read'
   mov al, dh   ; al <- number of sectors to read (0x01 .. 0x80)
   mov cl, 0x02 ; cl <- sector (0x01 .. 0x11)
                 ; 0x01 is our boot sector, 0x02 is the first 'available' sector
   mov ch, 0x00 ; ch <- cylinder (0x0 .. 0x3FF, upper 2 bits in 'cl')
   ; dl <- drive number. Our caller sets it as a parameter and gets it from BIOS,(0 = floppy, 1 = floppy2, 0x80 = hdd, 0x81 = hdd2)
   mov dh, 0x00 ; dh <- head number (0x0 .. 0xF)

   ; [es:bx] <- pointer to buffer where the data will be stored
   ; caller sets it up for us, and it is actually the standard location for int 13h
   int 0x13      ; BIOS interrupt
   jc disk_error ; if error (stored in the carry bit)

   pop dx
   cmp al, dh    ; BIOS also sets 'al' to the number of sectors read. Compare it.
   jne sectors_error
   popa
   ret

disk_error:
   mov bx, DISK_ERROR
   call print
   call print_nl
   mov dh, ah ; ah = error code, dl = disk drive that dropped the error
   call print_hex ; check out the code at http://stanislavs.org/helppc/int_13-1.html
   jmp disk_loop

sectors_error:
   mov bx, SECTORS_ERROR
   call print

disk_loop:
   jmp $
; DISK_ERROR → 标签，表示字符串的起始地址
; db → define byte，定义一系列字节
; "Disk read error" → 字符串内容，每个字符占 1 字节
; 0 → 字符串结束标志（NULL 终止符），方便函数或 BIOS 调用判断结束
DISK_ERROR: db "Disk read error", 0
SECTORS_ERROR: db "Incorrect number of sectors read", 0
```